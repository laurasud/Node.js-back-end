var _ = require('lodash');
var assert = require('assert');
var pathUtil = require('path');
var debug = require('debug')('express-routes-loader');
module.exports = function routesLoader(app, options) {
  if(arguments.length < 2){
    options = app;
    return load$routes;
  }else{
    return load$routes(app);
  }
  
  function load$routes(app) {
    options = options || {};
    if (_.isString(options)) {
      options = {
        path: options
      };
    }
    var routeRootPath;
    try {
      routeRootPath = pathUtil.resolve(__dirname, pathUtil.resolve(app.get('$boot_dir') || '',options.path));
      routeRootPath = require.resolve(routeRootPath);
    } catch (err) {
      console.error('[routesLoader]Cannot resolve routes directory path! given: ' + options.path, err);
      routeRootPath = undefined;
    }
    assert(typeof routeRootPath === 'string', '[routesLoader]routes directory is not set appropriately! given: ' + routeRootPath);

    var routersMap = require(routeRootPath);
    var getRouterPaths = _getRouterPaths.bind(null, app),
        applyRouterToApp = applyRouterPath.bind(null, app),
        routerPaths = getRouterPaths({'/': routersMap});

    routerPaths = routerPaths.sort(function(a, b){
      return b.length - a.length;
    });

    _.each(routerPaths, applyRouterToApp);

    function _getRouterPaths(app, routersMap) {
      if (!_.isObject(routersMap) && !_.isFunction(routersMap)) {
        throw new TypeError('[getRouterPaths]wrong input type! given: ' + routersMap);
      }
      if (_.isFunction(routersMap) && !isRouter(routersMap)) {
        routersMap = routersMap(app);
      }
      if (isRouter(routersMap)) return [routersMap];
      
      return mapFlatten(_.mapValues(routersMap, getRouterPaths), mapUnshift);
    }
  }
};
//helpers
function isRouter(r) {
  return _.isFunction(r) && _.isFunction(r.use) && _.isFunction(r.get) && _.isFunction(r.post) && _.isFunction(r.all);
}

function normalizePath(paths) {
  assert(_.isArray(paths), '[routesLoader::normalizePath]input should be an array! given: ' + paths);
  if (!paths.length) return '/';
  var pathStr = paths.map(function(p) {
    return p.replace(/\s+/g, '');
  }).join('/');
  pathStr = ('/' + pathStr + '/').replace(/\/([\/\s]*)\//g, '/');
  return pathStr;
}

function applyRouterPath(app, routerPath) {
  assert(_.isArray(routerPath), '[routesLoader::applyRouterPath]input should be an array! given: ' + routerPath);
  var len = routerPath.length,
    paths = routerPath.slice(0, len - 1),
    router = routerPath[len - 1],
    route = normalizePath(paths);
  debug('route %s added', route);
  app.use(route, router);
}
//common utils
function mapFlatten(arr, iterator) {
  return _.flatten(_.map(arr, iterator));
}

function mapUnshift(arr, toBeInsert) {
  return _.map(arr, function(item) {
    if (_.isArray(item)) {
      return (toBeInsert !== '/' || item[0] !== '/') ? [toBeInsert].concat(item) : item;
    } else {
      return (toBeInsert !== '/' || item !== '/') ? [toBeInsert, item] : [item];
    }
  });
}
